Saga
	Can be thought as a seperate thread that handles only side-effects. 
	Allows to send (dispatch) the action normally, unlike thunk
	Then you set up a watcher, that catches an action when it is dispatched. (catch in the middle)
	When it catches; 
		- 1. do the async. task
		- 2. dispatch another action that will reach... the user??
		
	When we create a watcher function, wee pass it inside the run() method as a parameter.
	Then it starts observing
	
  Saga Helpers
	- takeEvery : take every matching action and run the saga, can run concurrent tasks
	- takeLatest : take every matching action and run the saga, but CANCEL previous tasks
	
  Effect Creators
	Return plain JS objects, don't perform any execution.
	They are given to middleware like instructions.
	Middleware examines each effect desc. and performs the appropriate action
	
	- call : runs a function, if it returns a promise, pauses the saga until the promise is resolved
			This is where to do api requests.
	- put : dispatch an action
	
	Setting up saga for a project:
	- index.js : import { createStore, applyMiddleware } from 'redux';
	- 			 import createSagaMiddleware from 'redux-saga';
	
	-			 const sagaMiddleware = createSagaMiddleware();
	- 			 const store = createStore(reducer, applyMiddleware(createSagaMiddleware));
	-			 sagaMiddleware.run( yourWatcher );
	
	
	watcher Ex:
		function* myActionAsync() {
			yield put({ type: 'ACTION_TYPE_ASYNC', value: newValue }); // dispatch to reducer
				...
		}
		
		export function* watchAction(){ // generator
			yield takeEvery('ACTION_TYPE', myActionAsync); // observe every action that dispatches
		}					// can also use action creators here
		
Flow:
	1. Watcher catches the action dispatched from the component.
	2. Calls the async method defined (in saga.js) for that action (worker saga) // MIDDLE
		|_Perform extra stuff here
	3. The async action in saga dispatches the action to the reducer.
		
  
____________________________________________________-
Generators: 
	it has its own state.
	can be used to provide values for iterators
	can nest generators. ( use one gen. inside another one ) with *yield
	
	function* generator(){
		yield 1; // first call of nextl
		yield 2; // second call of next
		yield 3; // third call of next
		// return 'something' ==> this would stop the generator
		yield 4; // fourth call of next
	}
	
	function* generator(){ 
		let a = yield 1; // This pattern can be used to
		let b = yield 2; // provide an output based on the previous inputs.
		let c = yield 3; // (Pass an argument)
		// return a + b + c 
	}
	